tr - создает линию
td - создает ячейку
<form method = "get"> - передает все через URL
<"post"> - передать файлы
<a="link" target="_blank">

<h1 id="h1">				- элемент для прокрутки
<a href="#h1">  			- сделать ссылку на прокрутку

<button> type="reset" - очищает
type="submit" - отправляет

<input name=" "> - задать ключ
value=" ">  
type="submit" "reset" 
"checkbox" - отображает кнопку для галочки 
<label> - чтобы текст тоже был кликабельный (фокусировка)
tabindex="num" - в каком порядке переключаться между элементами формы (если -1, то пропускается)
type="radio" - добавляет кружок (почти multipy answer) (если одинаковые name=" " - то можно выбрать только один
type="password" - текст в виде точек (пароль)
type="file" - загрузить фото (multiple - несколько файлов)
type="data" - позволяет выбрать дату
type="datetime-local" - дату со временем
type="color" - выбрать цвет
type="email" - выглядит как обычное поле, но можно использовать только символы для почты
type="tel" - для телефонов. 
<input type="number" - для ввода цифр, можно кнопками увеличивать или уменьшать числа
max="num" min="num"> - не меньши и не больше
type="url" - для ввода сайтов
type="month" - год и месяц
type="search" - запоминает подсказки для поиска
type="range" - добавляет ползунок 
type="hidden" - невидимый для пользователя

line-height: (num)px   -задает высоту строки 
	можно инпутам задавать paddingи, чтобы было все четко при переносе строки.

-webkit-appearance: none; - убрать все стили у инпута (css)


autocomplete="off"	-отключить подсказки для инпутов

maxlenght="num" - максимальное количество символов
minlenght="num" - минимальное количество символов
disabled - отключить
required - обязательно для заполнения

<select>
	<option>text </option>		Выпадающий список
	<option>text2 </option>		с выбором
</select>

<option selected> - выбран по умолчанию

<optgroup label="name">   		сделать группу в селекте. label - дает имя группе
	<option> </option>
	

<textarea>
	text		позволяет растягивать текст, теги внутри не юзаются
</textarea>
rows="num" - задает изначальное положение (сколько будет строк изначально)

(сss)	resize: none							-будет появляться скорлл бар
		vertical						-можно менять размер только по вертикали
		horizontal						-можно менять размер только по вертикали


data-name="" 				- выдать атрибут (кастомный атрибут)

<hr/> - нарисовать линию
<br/> - перенести линию


CSS



style="background-color: " - сделать задний фон цвет
		transparent - прозрачный
		inherit	    - будет наследовать цвет от родительского элемента
		hsla(0,0%,0%,0.6) - затемнить экран  
	;background-image: url("ссылка") 	-сделать картинку на фон(она не будет подстраиваться под размеры)(можно через запятую еще одну картинку добавить, тогда в последующий свойствах через точку с запятой значение для второй картинки (если не задавать, то будут значения общие для всех))
			   linear-gradient((num)deg, color, color)		-добавить на фон градиент(если для двух значений сделать один процент то они будут переходить без градиента)
			   radial-gradient((num)deg, color, color)		-градиент будет из центра идти в края (все градиенты придерживаются правилам ниже также как и картинки)
		;background-size: cover		-чтобы картинка встала правильно
				  num(px)	-сделать ширину и длины картинки (картинка будет повторяться)
		;background-repeat: repeat	-картинка будет повторяться
				    no-repeat	-не будет повторяться
		;background-position: center 	-поставит картинку в центр 	(можно top center - тогда будет вверху в центре и т.п.) (если будет включен repeat, то будет повторяться по этой оси)
		;background-origin: border-box/content-box	-границу будет использовать тоже для фона (фон будет присутствовать прям на них)
		;background-attachment: scroll 		-умолчание
					fixed 		-картинку растянет на все элементы, картинка не скроллиться вместе с контентом
	;color:  	   - сделать цвет текста
	;opacity: (0-1)	   - регулирует прозрачность элемента и всего его содержимого
	;box-shadow: 5px 10px 10px 5px color (inset-тень будет внутри, а не снаружи элемента)   - задает тень  (первые две цифры - координаты,первая координата - ось X, вторая ось Y (можно использовать минусовые), третья цифра это размытие, четвертая - на сколько будет тень больше элемента)
	;text-shadow : 5px 10px 10px color 	- задает тень текста
	;width:		   - задать ширину
	;height:	   - задать высоту
	;min-width	   - 
	;min-height	   - минимальная высота элемента 
	;max-width	   -
	;max-height	   -
	;font-style:	   -выдать стиль 			
		     italic - курсив
		     oblique (num)deg - задать наклонность
	;font-family: (названия шрфитов через запятую),sans-serif	- добавляет другой шрифт тексту (если первого не будет, то идет следующий шрифт, который указан через запятую)
			monospace 					- консольный текст, где все буквы одинаковы по размерам
	;font-weight: (100-900) - задать жирность шрифта 	(normal-400) (использовать только значения, кратные 100)
	;font-size: (num)px - сделать размер шрифта
			 pt - как в ворде размер (аналог пикселям)
			 em - 1em=размер шрифта от body (можно использовать много для чего)
			 rem - такжде как и еm, считается от <html>
	;line-height: (num)px 						- меняет размер строки 	(можно использовать просто цифру без измерений, будет учитывать от стандартного размера (2=в 2 раза больше от начального)
	;outline: (num)px solid color:					- добавляет границу вокруг внешней границы элемента
		outline-width: (num)px 					- задать ширину оутлайна
	
	clip-path: circle(0, 100%, 0)(первое значение - X, второе - Y и по кругу)		-выдавать точки и по ним строится круг вроде	(свойство само по себе вырезает визуально из элемента то, что указали в координатах (обрезает вообще все))			
		    elippse()									-выдавать центр, и край, он обрезает углы 
		    polygon()									-выдавать точки и потом они соединяются	
			polygon(evenodd, )						-если будет пересекаться, то вырежет все внутри себя)

	;pointer-events: none						-элемент не получает событий от курсора (не работает hover и т.п.)	
	
	;cursor:							-как будет выглядить курсор при наведении
		 pointer						-указательный пальчик
		 n-resize						-стрелка двойная вверх и вниз
		 (тут можно много разных названий курсоров)
	
	filter: 
		blur(num)px						-размыть элемент 	
		brightness(num)						-поменять яркость			-везде можно добавить 0 чтобы выключить, и например включить только при наведении или наоборот
		grayscale(1)						-сделает все в серых оттенках
		drop-shadow(px px px color)				-добавляет тень, которая может учитывать прозрачность PNG
		
	text-decoration: underline 					-подчеркнет текст						
			 underline dotted				-подчеркнет точками
			 dotted line-through				-перечеркнет текст
				
				text-decoration-color: (color)					-задаст цвет 
				text-decoration-thinness:(num)					-задает толщину
	
	columns: (num)							-поделит текст на несколько колонок
			сolumn-gap: (num)				-ширина пространства между колонками 	(там еще много есть свойств с column)	
						
	-webkit-background-clip: text;					-мы будем видеть только то, что за символамми текста. можно накалякать картинку и потом "вырезать" все лишеюе
	
			-webkit-text-fill-color: transparent;		-отключить фон			

	transform: 								-перемещает элемент от своей изначальной позиции, изначальное место элемента остается (если в процентах, то от размера элемента считается) (можно отрицательные значения, будет в обратную сторону)
			translateX(numpx)						-пермещает по оси X		(-numpx будет сдвиг влево)	ЛАЙФХАК(чтобы расположить по центру от родителя - translateX(50%)
			translateY(numpx)						-пермещает по оси Y		(-numpx будет свдиг вверх)
			translateZ(numpx)						-пермещает по оси Z
			translate(numpx, numpx)						-пермещает по оси X и У
			translate3d(numpx)						-перемещает по трем сторонам	
						
			transform: scale(2px, 0.5px)					-увелчит размер ширину в два раза, а высоту уменьшит в два раза. (первая цифра эта X, вторая Y) (растягивается относительно центра)
			
			transform-origin: top left/bottom right/другое			-указывает какая точка будет "якорем" 	точка, от которй будут идти расчеты

			transform: skewX(45deg)						-искажает элемент на сколько-то градусов. В данном слчае по оси X на 45 градусов. Вместо Х можно ставить Y (минусовые тоже можно использовать)
				   skew(45deg 45deg) 					-искажает сразу по двум осям на 45 градусов

			transform: rotateZ(30 deg)					-повернет по оси Z на 30 градусов 		(по другм осям тоже можно)
			
			transform-style: preserve-3d					-чтобы элементы вели себя как в 3д 		(выдается родителю контейнеру)

					perspective: (num)px 				-выдается родителю, чтобы исопльзовать rotate (чем меньше перспектива, тем больше искажение)

	transition: all	(будет ко всему) (если написать background - то анимируется только цвет) (num)s		(style)		- изменение анимации 		(применяется, когда элемент хоть как-то меняется)
			(лучше указывать не при наведении а у самой кнопки сразу)				linear - 	-линейная, все с одной скоростью
			(c auto не работают transition)								ease-in 	-медленнее начинаем, быстрее заканчиваем
													ease-out	-быстрое начало, медленный конец
														ease-in-out	-быстро только в начале
			transition-property:		
			
			transition-duration:
			
			transition-delay: (num)s					-пауза перед анимацией

			transition-timing-function: 
	
						
	animation:	@keyfreames (animation-name){
							0%{здесь задавать любые свойства;}	
							50%{CSS свойство;}					-проценты от времени
							100%{здесь тоже задавать любое css свойство;}
								}
								
			animation-name: (name);							-задает имя анимации
			
			animation-duration: (num)s						-задает длительность
			
			animation-delay: (num)s							-задает задержку
	
			animation-timing-function: linear					-задать функцию анимации

						   stpes(num)					- делает колчество шагов в анимации, сколько указано в num, столько и будет прерывистых дейстивй

			animation-iteration-count: (num)/infinite				- сколько раз будет повторяться анимация 
				
			animation-direction:	normal(доходит до конца и идет занова		-в каком направлениии будет анимация 
						reversed(начинает с конца, идет до начала)
						alternate(туда сюда) 
						alternare-reversed(сюда туда)                                      	
		
			animation-fill-mode: 	none(вернется к исходному)			-задает конечный режим анимации
						forwards(застынет на конечной точке)
						backwards(сделает анимацию из ничего и дойдет до конца)
						
	text-transform: uppercase								-все буквы будут заглваные
			
	;overflow:	   - что делать если содержимое вываливается из контейнера
		hidden; - сделать невидимым
		visible; - оставить как есть (видимым)
		scroll; - сделать скроллбар
		auto; - автоматически добавляет скроллбар если есть переполнение 
		;overflow-x: настроить переполнение оси у
		;overflow-y: настроить переполнение оси х
		;text-overflow: elipces
		;overflow-wrap:break-word  			-чтобы слова не переносились  
		

	;margin:	   - создает отступы со всех сторон  (auto) - автоматически по центру
		margin left: auto - автоматический отступ слева
		margin right: auto - автоматический отступ справа
	
	;padding:(num)px           - делает обивку в пикселях
		padding-top: (num)px			делать
		padding-bottom (num)px			отсутпы 
		padding-left: (num)px			со всех
		padding-right: (num)px 			сторон
		padding: (num)px (num)px (num)px (num)px - верх,право,низ,лево.
		padding: (num)px 10px (num)px -верх и низ = num, лево и право - 10. если сделать только два num, то это будет вертикаль и лево право.
	
	;box-sizing: 
		border-box;  - делает так, чтобы граница не добавлялась поверх, а вычиталась 
	
	border: (num) px solid(неприрывная) color - сделать границу
			 dotted(граница из точек)
			 dashed(чертачками)
			 double(двойная граница)
			 ridge(грацниа 3д(выпуклая))
		border-top,left,right,bottom: все значения можно настросить отдельно
		border-width: num(px)
		border-color: (несколько цветов отдельно границам)
		border-style: (стили(нужно выбрать стиль))
		border-radius: (num) - делает закругленные границы (каждые углы можно по отдельности настраивать как в паддингах) (50%-круг) (если хочешь текст в круге, то сделать паддинги с такими же значениями)
			border-top-left-radius: (num) (num) настроить угол по высоте и ширине (можно топ, лефт менять на боттом райт и т.п.)

	display:		-задает модель, которую мы настраиваем формулами ниже
		inline;		-cделать элемент инлайном
		block		-сделать элемент блочным
		inline-block	-сделать инлайнами элементы блочными (span)	
		table  		-занимает ширину только своего содержимого 
		none 		-элемент пропадает со страницы
		flex		-действует на детей классов
			flex-direction: row; -строка(умолчание) 
					row-reverse; -справа на лево, реверсия
					column; - превращаются в мелкие строчные блоки
					column-reverse; реверсированные колонны
			flex-wrap: nowrap  - умолчание	- запретить перенос
					wrap;   - все элементы, которые не помещаются, переносятся на следующую, иначе все будут в одной строке
					wrap-reverse - перенос идет вверх
			align-content: отвечает за расстояние между строками
			align-items:    stretch; -выровнить элементы(умолчание)
					center; - по высоте столько, сколько нужно их контенту, элементы будут отцентрированны, выравниваются относительно центра друг друга
					flex-end; - по концу
					flex-start; - по началу	
			justify-content: flex-start - по умолчанию
					flex-end - сдвинет в обратную сторону, но не поменяет текст .
					center - все выровняется по центру
					space-between - сделать свободное пространство
					space-around - пространство вокруг каждого элемнта
					space-evenly - более равномерный around
			order:		-делает порядок элементов
			align-self: center   - выравнивание по центру
				    flex-end - выравниване справа
			   	    flex-start - выравнивание слева
			object-fit: cover 	-вырежет фото (не растягивает а именно вырезает по ширине, обрезает) 
			float: left		-обтекание картинки текстом слева
			       right		-обтекание картинки текстом справа	
			clear: (сторона) 	-запретить обтекание с какой-либо стороны (both-запретить с двух сторон)

		
		grid;				-сетка, все элементы растянутся на всю высоту ровно
			grid-template-rows: 100px 1fr 1	fr		-тут через пробел писать размеры всех строк, первая ячейка будет 100пикселей, вторая будет на половину остального, и третья на другую половину(можно также и auto, будет размером по тексту)
							fr - единица измерения только в grid, используется для того, чтобы писать сколько частей будет занимать ячейка. измеряется в долях от свободного пространства
			
			grid-template-columns: 100px 1fr 1 fr 		--тут через пробел писать размеры всех колонок, тоже самое что и со строками, только колонки

			grid-column-start; grid-column-end; grid-column-start; grid-column-end; тут более длинная запись того, что находится сверху

			row-gap: (num)px				-расстояние между строками
			
			column-gap: (num)px				-расстояние между колонками

			grid-template-areas: "head head head" 
					     "nav main main"			-создать грид сетку при помощи названий, там можно брать произвольные имена
					     "nav foot foot"
						

	ДЛЯ ДЕТЕЙ (ячеек)
			grid-area: 				-тут указывать через все координаты
			
			grid-column: 2 / 5;			-указываем, где будет элемент по колонкам, тут будет от второй линии до 5ой
				     2 / span 2; 							   тут от второй линии и еще на 2 
				
			grid-row: 2 / 3;			-указывать по линии, здесь будет между второй и пятой
				  2 / -1;					     здесь будет от второй до самой последней линии
			
			order: (num) 				-выдается элементам, можно задать порядок элементам.
		
		
	ДЛЯ ДЕТЕЙ
	flex-grow:	-может увеличивать размер больше первоначального 		(0-отключить) 
	flex-shrink:	-может уменьшать размер меньше первоначального 			(0-отключить)
	flex-basis:	-стандартный размер						(можно выдовать размеры просто цифрами через пробtk flex: (1(flex-grow) 2(flex-shrink) 3(flex-basis))
	
	align-self: 	-выравнивает по вертикали один элемент						 
	
	;position:
		static; 		-стоит там где стоит (default)
		relative;		-для всех других элементов стоял там где стоял 
		absolute;		-поставить в абсолютную позицию от родительского элемента с position, вытаскивается из контекста. перестает существовать для других элементов (слева сверху)
		sticky:			-перемещается только внутри своего контейнера, почти как display fixed.		(bottom: 0, если уйдет ниже элемента, то он прилипнет к низу, тоже самое и с топ)

			right: calc(50% + 52px) - сдвинет вправо на 50% и 52 пикселя

		fixed;			-даже при скроллинге продолжает оставаться на месте, все время отсчитывается от окна 
						

				top: (num), left:(num) и т.д. 	-менять позицию относительно первоначального положения 
				z-index: (num без измерений) 	- задает на каком слое лежит элемент (элементы с разных классов друг с другом не конкурируют)
 
	;top,bottom,right,left



backface-visibility: hidden		-видна ли задняя сторона у элемента
repeat(


@media(свойство: ){
css
}

<meta name="viewport" content="width=device-width, initial-scale=1.0"> - вставить в начале, чтобы работало все адоптивно


	@media (max-width: 800px) {} 	- работает, если экран меньше 800 пикслей
											-можно использорвать с разными пикселями несколь раз, чтобы все было чики пуки
	@media (min-width: 800px) {} 	- работает, если экран больше 800 пикселей
	
	@media (max-width 800px) and (min-width: 500px) {} - работает в промежутке от 500 до 800 пикселей
	
	@media (orientation: landscape)  {} - на телефоне вертекально
			       portret)  {} - на телефоне горизантально


	@media screen {} - применяется только на устройстве с экраном 			- это все кроме принтеров
	
	@media print {} - применяется во время печати 

<style>
	div{
		background-color:			для всех div применяется (можно в отдельном файле)
		;color:
	}
</style>

<link href="" rel="stylesheet"/>

:root{						-используется, чтобы задать переменные)
  --name: свойство;				-(здесь можно выдавать переменные и свойства им. потом их удобно менять и использовать) (такжей с цветами круто)
}
	var(--name)	-это уже использовать в коде, где нужно применить эту переменную

#-<id>
.-<class>	



SCSS



@mixin name{
	свойство;			-задать свойства для дальнейшего применения 
	свойство;
}

.block{
	@include (mixin name);		-использовать использовать заданные свойства из @mixin
}


$name: (color) (num) (все что угодно)			-выдавать переменную для использования, можно пиксели, можно цвета

там где выдавать можно делать: $name * num 		-умножится значения переменной, можно умножать также на проценты и пиксели.
				все математические свойства можно

@if (что-то == что-то){
	свойства
	свойства
{ @else {
 	другие свойства
	другие свойства
}


color
	:lighten($color, num%)					-осветить переменную цвета на 20 процентов
	:darken($color, num%)					-отемнить
	:saturate($color, num%)					-сделать более насыщенным
	:desaturate($color, num%)				-сделать менее насыщенным
	:transparentize($color, 0.5)				-сделать прозрачным в два раза
	:adjust-hue($color, num)				-цвет, с двигом на какойто шаг	



SELECTORS

class > tag{} - тэги первого уровня (только на первой ветке в одном классе)
selecotr + selector{} - соседи (только первый сосед)
selector ~{} - все последующие (соседи снизу)
tag.class{} - выбрать только этим тэгам в определнном классе
div div{} - все div которые находятся в div
*{} - вообще ко всему
:focus-within{} - применяется к родительскому элементу если есть хоть один элемент в фокусе
:hover{} - при наводке курсором работает только 
:active{} - для ссылок, действует во время, когда нажали, но еще не отпустили 
:visited{} - для ссылок, которые уже посещали 
input:focus{} - когда фокусриуешься тогда работает (для инпута круто) (элементы инпута и ссылок, для табулияции )
:checked{} - для чекбоксов, которые отмечены
:disabled{} - для выключенных
:required{} - для обязательных
:invalid{} - для неправильных 
:first-child{} - для первых потомков
:last-child{} - выберет последний элемент 
:nth-child(2n){} -выберет все четные элементы
	  (2n+1){}- выберет все нечетные элементы (формулу можно менять)


::before{} - перед всеми указанными элементами			{:content "text"; }
::after{} -  после всех указанных элементов			content только для before и after 	

a[hreflang="ru"]{} - только для всех ссылок с атрибутом ru		

100%=100vh/100vw  -100% от экрана



JS

Экранировать кавычку - \ перед кавчыкой
=== - говорит интерпертатору, что нужно сравнивать тип данных тоже, тоесть 1 не будет равно "1"
!== - тоже самое что и сверху, только не равно
!(smth) - не smth
&& - и
|| - или 

сonsole.log()			- вывести что-то на экран

return name			- сохранить изменения переменной

parseInt("12321.2")		- первратит строку в число (причем превратит только целое число, остаток исчезнет)
parseFloat("num")		- тоже самое, только остаток сохраняет

Number("num") 			- превратит строку в число ( без контроля флоат и инт) 	- конвентатор в числа 
String()			- превратит что угодно в строку

let name = значение 		- задать переменную 
name = значение 		- выдать новое значение переменной
name -= num			- отнимет от переменной num   
     *= num			- умножет на num	 
сonst name = значение 		- задать переменную, которую уже нельзя поменять 


function name(аргументы){ 	-задать функцию
	код
}

let name = function(аргумент){	-задать функцию
	код
}

let name = (аргумент) =>{	-задать функцию
	код
}


функция
 ? (дейстиве, которое будет при правдивости условия)
 : (дейстиве, которое при не выполнении условия)
	можно вложить еще ? и : внутри ? и : (ну только в скобочках)


switch (переменная или выражение) {  
  case "name": 
    код;
  break;				-закончить case, после него можно написать еще один case

  default:				-будет отработан, если ни один сase не сработал (необязательно)
    код;
  break;	
}


if (name.lice(-1) === "something") {	-проверяет если заканчивается последний символ на чтото
  name.slice(0,-1) + "то, что хочу добавить";		- если заканчивается на какой-то символ, поменять на что-то
}	

break 					-дословно закончить цикл

name.length			-узнать длину строки
name(charAt(num))		-достать символ по индексу
name.slice(index, index)	-первый индекс указывает срезать с какого-то индекса, а второй - до какого.
name.indexOf("")		-узнать символ на каком индексе стоит
name.startsWith("")		-проверить начинается ли строка с определенных символов
name.endswith("")		-проверить, заканчивается ли строка на что-то
name.includes("")		-узнать, находится ли что-то в строке


Math.random()			-сгенерировать рандомное число от 0 (включительно) до 1 (невключительно) 
Math.floor(math.random()) 	-сгененрировать целое число от 0 до 10
(5+ math.floor(math.random() * 5)))	-сгенерирует целое число до 10	

Math.floor() 			-округляет число вниз	(к наибольшему числу снизу)
Math.ceil()			-округляет число вврех (к наибольшему числу сверху)
Math.trunc()			-отбрасывает все после запятой
Math.round()			-математическое округление (к ближайшему сверху или снизу (нормальное округление тоесть))
Math.min()			-выводит самое минимальное значение из массива 

Math.pow			-вводит в степень
Math.abs(num)			-модуль числа

while (условие/значение bull) {
 блок кода, который будет выполняться, пока условие верно		-цикл
}

do{
 блок кода
} while (условие/значение bull)						-другая вариация цикла

for(let i=что-то; условие; выполнение условия){
 блок кода								-вариация цикла с кодом
}  


"строка".padStart(num, "text")						-если строка меньше num, добавляет text
	.padEnd								-добавит в конец text

instanceof smth								-является ли экземпляром чего-то 
typeof smth								-узнать тип чегото
parseInt								-выводит только цифры, опускает буквы

new Date()								-отобразит текущею дату

Массивы

let name = [el,el,el,el]			-создание массива с 4 элементами
name.push()					-добавить еще один элемент в конце массива
name.pop()					-вытаскивает последний элемент с массива 
name.unshift()					-добавить в начало массива
name.shift()					-вытащить с начала массива
name.includes(12, "smth")			-проверить есть ли smth в массиве, начиная с 12 элемента, можно без начала искать
name.indexOf()					-проверить есть ли что-то в массиве, показывает его индекс  (-1  значит что нет)
name.some()					-применяется, если условие подходит хоть к одному
name.every()					-применятся, если условие подходит ко всем
name.filter(фильтр)				-выводит все элементы, подходящие под фильтр

name.map(функция)				-выполнит функцию для каждого элемента массива, добавит полученный результат в новый массив
name.from({ }, )				-тот же map, но игнорирует то, что ему передали
name.reduce((функция), старт. знач.)		-на каждый элемент массива делает функцию
name.forEach()					-работает как map, но не создает новый массив

name.reverse()					-переворачивает массив
name.sort()					-сортирует массив

name.slice()					-cкопировать массив от определенного индекса. Если не указать ничего, то скопирует весь массив
name.find()					-найти что-то в массиве
	
name.fill()					-заполнить массив чемто, можно частично, указав индексы
name.splice(индекс, сколько элементов удалить) 	-удаляет и вставляет элементы в определенное место в массиве. Если хочешь заменить, то нужно добавить третье значение, еще одна запятая - еще один элемент. Не вызывает новый массив, а изменяет старый 

...name 					-вставляем не массив, а конкретно его элементы, если там будет не массив, а строка, то все буквы по отдельности 
						-также из набора элементов может сделать массив 
name.join()					-соединит элементы между собой чем-то 

name.flat(infinity)				-выравнить массив, передаем насколько уровней нужно углубляться, чтобы выравнивать. Инфинити - все выровнит, не смотря на вложенность
.flatMap(x => [])				-флат + мап

if (){
  throw new Error("текст ошибки");		-выводит ошибку в консоль
}

yield ;						-как return только последовательно возвращает и в конце можно добавить return

Объекты

const name = {
  key: "value",					-задать обьект 
}

.smth() = ["smth"]()				-обратится к элементу двумя вариантами 

Object.entries(name)				-преобразовывает обьект в массив 

instanceof					-является ли что-то чем-то

obj.key() 					-обратиться к ключу обьекта

this.key					-обратиться к ключу который находится в этом обьекте
new 						-создать новый
.prototype 					-
class name{}					-з   адать класс со своими значениями
static						-остаются только на уровне самого прототипа
extends{}					-расширяет возможности чего-то
super()						-представляет родителя, ближайший прототип сверху 	
#name;						-сделать элемент приватным (доступным только внутри класса)

.toLowerCase()					-сделать буквы маленькими
[name, name] = name.split("разделитель")	-разделить строку*

СВЯЗКА С БРАУЗЕРОМ

window.addEventListener("load", () => {});

.addEventListener.load 					- сработает, когда загрузится полностью страница и ее содержимое 
.addEventListener.DOMContenetLoaded 			- сразу же срабатывает

.addEventListener("keypress", (evenet) => {};		-обработчик события по нажатию клавиши на клаве
.addEventListener("keyup", (evenet) => {};		-обработчик события по нажатию клавиша когда ее нажали и отпустили
.addEventListener("keydown", (evenet) => {};		-обработчик события при нажатии (сразу же работает)
	if (event.code === "ArrowLeft") {		-если была нажата кнопка влево
		event.preventDeafault()	}		-на всякий пожарный

	switch (event.code) {
	  case "ArrowLeft":{				-если  была нажата левая кнопка
	  } break;

.addEventListener("scroll", (evenet) => {};		-обработчик события при скролле
	window.scrollX
	window.scrollY			
	window.scrollTo({				-заскроллить к чему-то
			top:0	
			behavior: "smooth"	})	-чтобы плавно было			

.addEventListener("mousewheel", (event) => {};		-обработчик события колесика мыши


event.ctrlkey ? : ;					-если был нажат в добавку ктрл

mousemove
mouseleave
mouseenet
mouseover

.innerText						-вывести текст из хтмл в консоль
.innerText = ""						-присвоить новый текст
.innerHTML = ""						-все полотно выведет, преявращает строку в хтмл код

document.
.getElementById("nameOfId")				-достает элемент по его #id
.getElementsByTagName("tag")				-достает все элементы с каким-то тегом (например, можно вывести все дивы)
.getElementsByClassName("class")			-достает все элементы по их class'у

.querySelector("")					-достанет первый элемент, удовлетворяющий запрос
.querySelectorAll("")					-достанет все элементы, удовлетворяющие запросу

document.createElement("tag")				-создать тег

body.append()						-добавить элемент в хтмл (добавляет в конец)
    .appendChild()					-добавить ребенка
	
.inserBefore(то что добавляем, то-перед чем добавлять)	-вставить элемент перед каким-то другим

.removeChild(то что удаляем)				-удалить элемент (вызывается у родителя этого элемента)

a.href = ""						-установить ссылку для ссылки
a.id = ""						-установить айди для ссылки
a.classname = ""					-устанавливаются классы через пробел
a.classList						-превратит классы в массив

a.classList.remove("")					-убрать класс у элемента
a.classList.add("")					-добавить какой-то класс к элементу
a.classList.toogle("")					-добавляет класс, если его нет или убирает, если он есть
a.classList.contains("")				-проверить на наличие какого-то класса

element.onclick = () => {}				-обработчик при нажатии
element.dataset.key = "value";				-задать хтмл элементу индекс и информацию

settimeout(() => {функция}, 2000)			-задает интервал
	{clearInterval(имя интервала);}			-выключить интервал (добавлять в фигурные скоби внтури интервал)

Date.now();						-количество милисекунд, прошедчих с января 1970 года

.clienWidth / clientHeight 				-размер контента + паддинга
.offsetWidth / offsetHeight 				-размер контента + паддинга + скролл баров + границ

.offsetTop / offsetLeft					-координтаы относительно родительского узла

.getBoundingClientRect()				-получить координаты элемента относительно левого верхнего угла

.clientWidth						-длина блока 
.offsetX						-показывает отступ мышки по оси Х относительно дом элемента

Math.sign()						-показывает положительное или отрицательное значение 

Promise
Promise.resolve(2);					-
.then((value) => {});					-выполняется после Promise
.catch(reason => {});					-если произойдет какая-то ошибка
await							-ждать окончание чего-то
async							-сделать функцию асинхронной

Promise.all						-результат новый промис, который завериштся когда вся завершатся
Promise.race([functions])				-как какой-то закончится то завершится

try{}							-попробовать выполнить какой-то код, но не выводит ошибку
catch (название переменной){}				-в эту переменную запишется ошибка из трай
finally {}						-что будет после трая и катча

el.insertBefore(el1, el2)				-вставит el1 перед el2



CANVAS


const context = canvas.getContext("2d");

context
.clearRect(0,0)						-очистить
.rect(координаты)					-добавить фигуру
.fillRect(координаты)					-залить по координатам
.fill()	  						-залить (автоматически делает клоус пас)
.fillstyle="";  					-после этого везде будет использоваться этот цвет

.moveTo(координаты)					-переместить путь кудато (переместиться)
.lineTo(координаты конечной точчки)			-провести линию от moveTo к lineTo			/в конце клоспас и в начале бегинпас для результата
.lineWidth = число					-ширина линии
.stroke();						-обводка
.strokeStyle="цвет";					-цвета обводки

.translate(координаты)					-сместить начало координат у канваса			/если два раза применить, то они будут накапливаться
.scale(цифра, цифра)					-масштабирование по X и Y
.rotate(градус в радианах)				-повернуть начало координат на сколько-то градусов


.beginPath();													/когда делаешь новый бегинпас, старый закрывается
все что тут - один путь
.closePath();

.arc(две, координаты центры, радиус, угол, финальный угол(2*Math.Pi для круга))					-забабахать дугу (круг)

.save()							-сохранение
.restore()						-вернуться в состояние в момент сохранения (save'a)

.fillText("текст", координаты две, максимальная ширина(необязательно))						-добавить текст
.textAlign = "center/end/т.д."											-выравнить текст
.textBaseLine ="top"												-по игрику выравнить, переданные координаты при top являются вершиной текста
														/scale'ом можно увеличить текст
.font = "СSS по шрифту одной строкой"										-настройки текста

requestAnimationFrame(функция)				-перед новым риснованиям вызовает выданную  функцию

.drawImage(координаты 4)											-добавить картинку в канвас


FORMS

document.forms.["названиеформы"]										-обратиться к форме 
form.elements["имяэлемента"]											-обратиться к элементу формы
														
form.addEventListener("submit", (event) => {									
	код;													-что делать если форма была отправленна 
})														//event.preventDefault() чтобы не отправлялась

														//value у чекбокса отправляется в случае отправки формы
														//value у элементов формы это то, что ввел пользователь

nameofcheckbox.checked												-проверить отмечен ли чекбокс 

nameofradiobutton.value
nameofradiobutton.selectedIndex											-сделать радио кнопку изначально выбранной

nameoffield.disabled = true											-сделать какое-то поле выключенным

Array.from(FormData(nameOfForm).value())									-сразу только отправленные значения 

formElement.addEventListener("change", (event) => {								
	код;													-когда поменяли значение формы и перешли к другому
})

formElement.addEventListener("input", (event) => {
	код;													-когда мы чтото пишем в инпут
})

formElement.addEventListener("blur/focusout", (event) => {
	код;													-когда потеряли фокус
})
                                                                                                                   

`строчное врыажение ${выражение} строка ${выражение} строка строк строка строчная`				-обычная строка, но прокаченная, где можно сразу писать выражение без всяких плюсов и прочей заморочки ``




REGULAR EXPRESSIONS


\n -символ переноса строки	
													
/rеgулярное значение/;												-задать регулярное значение
new RegExp("чтото", "флаги");											-задать регулярное значение

FLAG G 	- нашел только одно первое совпадение и на этом хватит
FLAG M	- новое слово - новая строка
FLAG I	- дает независимость от регистора (большие и малые буквы - одно и тоже)

^text														-будет искать text только у начала слова/строки
$text														-ищет text в конце строки
.														-абсолютно любой символ
.\														-экранировать символ (тоесть выключает его специальное значение)
[символы, которые хотим найти]											-каждый символ здесь одельный считается 
[^text]														-нади все кроме text
[a-z]														-найди все буквы от a до z с
\d														-найти все цифры
\D														-все кроме цифр
\w														-все символы слов
\W														-все кроме словесных символов 
\s														-искать все пробелы (табуляция, пробел, перенос строки)
\S														-искать все кроме пробелов
  *														-искать любое количество чего-то (.* - любое количество любых символов) 
  +														-искать один и больше (\s\s* - уберет все пробелы, которых больше одного) (если написать слово в скобках и потом + то будет искать один и больше количество символов в скобках)
 {num}														-искать num количество чего-то ({2,10} найдет от двух до 10, если 10 не написать, то будет от 2 до бесконечности)
(text|txet)													-найти text либо txet
  ?														-{0,1} (может быть может не быть)
\b														-найти границу слова
\B														-все кроме границ слов
\num														-искать что-то как в группе num (группы делаются при помощи круглый скобок ())
(?=rex)														-не ищем rex
(?<!rex)чтото													-найти что-то, перед которым нет rex
[^rex]														-не rex
?<name>														-дать имя группе


В JAVASCRIPT
rex.test("str")												-проверить совпадает или нет
"str".match(rex)											-показывает все совпадения и все
"str".matchAll(rex)											-показывается все совпадения, группы совпадений и всякое такое (продвинутый match)
"str".replace(rex, "smth")										-заменить rex на smth (замена)


FILES

FileReader()												-задать читатель файла

input.files[0]												-обратиться к файлу
reader.readAsText(file)											-читать как текст
reader.readAsDataURL(file)										-читает в закодированном виде, можно использовать как URL

file.size												-размер файла


Dates

new Date(2021, 1, 1)											-передать дату со значением первого февраль 21 года  (месяцы начинаются с 0 - январь)
date < date												-с датами можно делать операции, также как и с числами (поведение у них, как у объектов)
date - date												-столько прошло милисекунд с даты какой-то
date + число												-прибавит к дате количество милисекунд

date.getDate();												-дает день месяца
date.getDay();												-дает день недели (воскресенье - 0)
date.getMonth();											-даст месяц
date.getFullYear();											-год
date.getTime();												-в милисекундах  (valueOf - тоже самое)
date.getUTCHours();											-даст часы в UTC формате
date.getTimezoneOffset();										-сколько минут разницы с UTS
date.toString();											-распечатывает даты в разных форматах								

date.setFullYear(год)											-установить год на какой-то	
date.setDate(выражение или число)									-установтиь какой-то месяц (можно прибавить текущую дату) /изменяет но не возвращает



JSON

JSON.stringify(объект)											-превращает объект в строку в формате JSON (можно отправить ее по сети или на сервер)
JSON.parse(строка)											-превращает строку обратно в объект (это когда с сервера пришли данные и надо их преоборазовать) 

fetch("URL откуда хотим получить данные")								-получаем данные
then(response => code)											-чтото сделать

PUT - меняет
DELETE - удаляет



Cookies

параметры разработчика => application => cookies


window.document.cookie											-печенька
window.document.cookie = "key=value"									-задать печеньку  (key всегда разный должен быть, иначе перезапишеться)			
		       = "key=value;max-age=sec"							-задать печеньке срок жизни в sec 
		       = "key=value;path=/search"							-показывает в рамках какого пути он будет доступен

window.encodeURIComponent("строка")									-все недопустимые символы закодируются, заккодирует как компонент ссылки
window.encodeURI("строка")										-закодирует как ссылку (/ и подобные символы не будет убирать )
window.decodeURI("строка")										-раскодирует ссылку



IndexedDB

параметры разработчика => application => indexedDB

indexedDB.open("имя", цифра версии);									-создание индексед
request = window.indexedDB.open("name", version)							-создать индекседдб, version принимает цифру


request.addEventListener("success", (e) => {}								-при успехе что делать 
request.addEventListener("error", (e) => {}								-при ошибке что делать 
request.addEventListener("upgradeneeded", (e) => {}							-работает, когда поменяли версию 

db = request.result
db.createObjectStore("name, {
	keyPath: "id",											-сделать обьект в базе данных (сам генерирует ключи)
   ЛИБО autoIncrrement: true										
});

transaction = db.transaction("название objectstore'a, "мод")						-группирует много действий одновременно (для двух действий success обязательный)
						      "readwrite"
						      "readonly"

store = db.createObjectStore("имя, {
       keyPath: "id"											-cоздать обжектстор
    });

transaction.addEventListener("complete", (e) => {}							-что делать когда все сделал

store.transaction.objectStore("имя objectstore'a")							-задать переменную для обджекстора
store.add({})												-добавить новую запись новым ключом (insert)
store.put({												-добавляет новую либо перезаписывает старую (insert OR update)
	id: num,					
	key: "value:, })										
store.delete(key или айди)										-удалить что-то
store.count(ключ либо промежуток ключей либо ничего)							-посчитать
store.getAll()												-достать чтото
store.getKey() 												-возвращает ключ

IDBKeyRange.bound(num, num, true, true)									-выводит в промежутке от num до num включительно (если false спереди, то первый элемен тне войдет)
